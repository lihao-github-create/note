# 面向对象编程详解

## 抽象类 vs. 接口

### 从语法特性角度

抽象类具有以下特性：

- 抽象类不允许被实例化，只能被继承。
- 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含。不包含代码实现的方法叫作抽象方法，在c++中也叫作纯虚函数。
- 子类继承抽象类，必须实现抽象类中的所有抽象方法。

在 C++ 中，可以使用 virtual + '= 0' 关键字来声明纯虚函数，包含纯虚函数的类叫作抽象类。

```cpp
class Logger {
 private:
    std::string name;
 public:
    virtual doLog() = 0; // 这是一个纯虚函数
};
```

接口具有以下特性：

- 接口中不能包含属性，只能包含方法；
- 接口中只能声明方法，且方法不能包含实现；
- 类实现接口的时候，必须实现接口中声明的所有方法。

在 C++ 语言中，不像 java 那样支持接口 interface。但可以通过抽象类来模拟类似于 java 的 interface。

```cpp
class Logger {
 public:
    virtual doLog() = 0; // 这是一个纯虚函数
};
```

### 从设计的角度

抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种 is-a 的关系，那抽象类既然属于类，也表示一种 is-a 的关系。

相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

### 抽象类和接口能解决什么问题

抽象类能解决代码复用问题：

- 多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码；
- 支持多态，这样一来，使用者就可以写出与子类类别无关的代码。虽然虚函数也可以做到，但纯虚函数（抽象类）有以下优点：
  - 虚函数必须给出一个空的实现，用纯虚函数更为直观，可读性更强；
  - 包含虚函数的类可以被实例化，无法从语法上进行限制；
  - 子类可能忘记重写虚函数，但纯虚函数编译器会报错。

接口能解决接口与实现耦合的问题：

接口是对行为的一种抽象，相当于一组协议或者契约。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

虽然说抽象类也可以实现类似接口的功能，但接口的粒度更小，且语义更清晰。比如说鸟类继承体系和飞机类继承体系，大部分鸟类和飞机类可以共用Fly这一interface。在仅需要Fly这一interface，就可以很好地实现接口和实现的分离。

### 如何决定使用抽象类还是接口

如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。

从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

但是，接口存在一个问题，就是不能给出具体地实现。这意味着如果子类关于某个接口的实现完全一致，将会导致要实现多份。这时就需要用“组合+接口”的方式来实现。

## 基于接口而非实现编程

### 如何理解原则中的“接口”

“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。

从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接
口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，**可以理解为编程语言中的接口或者抽象类**。相反，实现则指的是实现类。

实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

### 如何制定接口

在制定接口时，需要做到以下几点：

- 命名要足够通用，不能包含跟具体实现相关的字眼。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。
- 与特定实现有关的方法不要定义在接口中。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。

总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

### 是否需要为每个类定义接口

这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。

从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。
